<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comentários em Tempo Real</title>
    <link rel="icon" type="image/x-icon" href="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1d/Google-flutter-logo.svg/1024px-Google-flutter-logo.svg.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #282c34;
            color: #f8f8f2;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            background-color: #33363d;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            padding: 25px;
            width: 100%;
            max-width: 700px;
            box-sizing: border-box;
        }

        h1 {
            color: #61dafb;
            text-align: center;
            margin-bottom: 25px;
            font-size: 2.2em;
        }

        .auth-section, .comment-input-section, .comments-section {
            margin-bottom: 25px;
            padding: 15px;
            background-color: #3a3f47;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        input[type="email"],
        input[type="password"],
        input[type="text"],
        textarea {
            width: calc(100% - 20px);
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #555;
            border-radius: 5px;
            background-color: #444;
            color: #f8f8f2;
            font-size: 1em;
            box-sizing: border-box;
        }

        input::placeholder, textarea::placeholder {
            color: #bbb;
        }

        button {
            background-color: #61dafb;
            color: #282c34;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            margin-right: 10px;
        }

        button:hover {
            background-color: #21a1f1;
        }

        button:last-child {
            margin-right: 0;
        }

        .auth-buttons button {
            width: calc(50% - 5px);
            box-sizing: border-box;
            margin-bottom: 10px;
        }

        .auth-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
        }

        .comment {
            background-color: #4a4e58;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease-in-out;
            border-left: 5px solid #61dafb;
        }

        .comment.own {
            border-left: 5px solid #28a745;
            background-color: #4f535d;
        }

        .comment.admin {
            border-left: 5px solid #ffc107;
            background-color: #555963;
        }

        .comment-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 10px;
        }

        .comment-author {
            font-weight: bold;
            color: #61dafb;
            font-size: 1.1em;
        }

        .comment.own .comment-author {
            color: #28a745;
        }

        .comment.admin .comment-author {
            color: #ffc107;
        }

        .comment-timestamp {
            font-size: 0.8em;
            color: #bbb;
        }

        .comment-message {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .comment-actions button {
            padding: 8px 12px;
            font-size: 0.9em;
            margin-right: 8px;
            margin-top: 5px;
            background-color: #5a5e6b;
            color: #f8f8f2;
        }

        .comment-actions button:hover {
            background-color: #727786;
        }

        .admin-buttons button {
            background-color: #dc3545; /* Red for delete/ban */
            color: #fff;
        }
        .admin-buttons button:hover {
            background-color: #c82333;
        }

        #status {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: bold;
            color: #f8f8f2;
        }

        #userCount {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1em;
            color: #61dafb;
        }

        #alert-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4CAF50; /* Green */
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            text-align: center;
            min-width: 250px;
        }

        #alert-box.error {
            background-color: #f44336; /* Red */
        }

        .markdown-cheatsheet {
            background-color: #3a3f47;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 0.9em;
            color: #ccc;
        }
        .markdown-cheatsheet h3 {
            color: #61dafb;
            margin-top: 0;
        }
        .markdown-cheatsheet ul {
            list-style-type: none;
            padding: 0;
        }
        .markdown-cheatsheet li {
            margin-bottom: 5px;
        }
        .markdown-cheatsheet code {
            background-color: #282c34;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            color: #e06c75;
        }
        .markdown-cheatsheet strong {
            color: #98c379;
        }
        .markdown-cheatsheet em {
            color: #e5c07b;
        }

        .mention {
            color: #8be9fd; /* Cor de destaque para menções */
            font-weight: bold;
            background-color: #555;
            padding: 2px 4px;
            border-radius: 4px;
        }
        
        /* Estilos para o prompt customizado */
        .custom-prompt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .custom-prompt-box {
            background-color: #3a3f47;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 400px;
            text-align: center;
        }

        .custom-prompt-box p {
            margin-bottom: 20px;
            color: #f8f8f2;
            font-size: 1.1em;
        }

        .custom-prompt-box input[type="text"],
        .custom-prompt-box textarea {
            width: calc(100% - 20px);
            margin-bottom: 20px;
        }
        .custom-prompt-box textarea {
            min-height: 80px;
            resize: vertical;
        }

        .custom-prompt-box button {
            margin: 0 10px;
            padding: 10px 20px;
            font-size: 1em;
        }
        .custom-prompt-box button.confirm {
            background-color: #28a745;
        }
        .custom-prompt-box button.confirm:hover {
            background-color: #218838;
        }
        .custom-prompt-box button.cancel {
            background-color: #dc3545;
        }
        .custom-prompt-box button.cancel:hover {
            background-color: #c82333;
        }

        /* Estilos para o popup de nome de usuário */
        #username-prompt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000; /* Acima de outros prompts */
        }

        #username-prompt-box {
            background-color: #3a3f47;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.7);
            width: 90%;
            max-width: 450px;
            text-align: center;
            border-top: 5px solid #61dafb;
        }

        #username-prompt-box h2 {
            color: #61dafb;
            margin-bottom: 20px;
        }

        #username-prompt-box p {
            color: #f8f8f2;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        #username-prompt-box input[type="text"] {
            font-size: 1.1em;
            padding: 15px;
            margin-bottom: 25px;
        }

        #username-prompt-box button {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            background-color: #61dafb;
            color: #282c34;
        }

        #username-prompt-box button:hover {
            background-color: #21a1f1;
        }

        /* REPLY BOX */
        #replyBox {
            background-color: #555;
            padding: 10px 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            display: none; /* Inicia oculto */
        }

        #replyMessageSpan {
            flex-grow: 1;
            color: #f8f8f2;
            margin-right: 10px;
            font-style: italic;
        }

        #cancelReplyBtn {
            background-color: #dc3545;
            color: white;
            padding: 8px 12px;
            border-radius: 50%; /* Torna-o redondo */
            width: 30px; /* Largura e altura para fazer um círculo */
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            line-height: 1; /* Alinhamento vertical do 'x' */
            margin-right: 0; /* Remove a margem extra */
        }

        #cancelReplyBtn:hover {
            background-color: #c82333;
        }

        /* Mention suggestions */
        #mention-suggestions {
            border: 1px solid #555;
            background-color: #444;
            max-height: 150px;
            overflow-y: auto;
            border-radius: 5px;
            margin-top: -10px; /* Sobrepor um pouco a borda da textarea */
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            display: none; /* Hidden by default */
        }

        .mention-suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            color: #f8f8f2;
        }

        .mention-suggestion-item:hover {
            background-color: #61dafb;
            color: #282c34;
        }

        .comment-reply-block {
            background-color: #666; /* Um pouco mais claro para se destacar */
            border-left: 3px solid #61dafb;
            padding: 8px 12px;
            margin-top: 5px;
            margin-bottom: 10px;
            border-radius: 4px;
            font-size: 0.9em;
            line-height: 1.4;
            color: #e0e0e0;
        }

        .comment-reply-block .reply-block-author {
            font-weight: bold;
            color: #61dafb; /* Cor da menção para o autor original */
            margin-right: 5px;
        }

        .comment-reply-block .reply-block-message {
            font-style: italic;
            color: #cccccc;
        }
        .comment-reply-block.comment-reply-deleted {
            background-color: #777;
            border-color: #999;
        }
        .comment-reply-block.comment-reply-deleted .reply-block-message {
            color: #999;
            font-weight: normal;
        }
          </style>
          </head>
<body>
    <div id="alert-box"></div>

    <div id="custom-prompt-overlay" class="custom-prompt-overlay" style="display: none;">
        <div id="custom-prompt-box" class="custom-prompt-box">
            <p id="custom-prompt-message"></p>
            <input type="text" id="custom-prompt-input" style="display: none;">
            <textarea id="custom-prompt-textarea" style="display: none;"></textarea>
            <button id="custom-prompt-cancel" class="cancel">Cancelar</button>
            <button id="custom-prompt-confirm" class="confirm">Confirmar</button>
        </div>
    </div>

    <div id="username-prompt-overlay" style="display: none;">
        <div id="username-prompt-box">
            <h2>Seja Bem-vindo!</h2>
            <p>Por favor, escolha um nome de usuário que será exibido para seus comentários.</p>
            <input type="text" id="usernameInput" placeholder="Seu nome de usuário">
            <button id="saveUsernameBtn">Salvar Nome</button>
        </div>
    </div>

    <div class="container">
        <h1>Comentários</h1>

        <div id="status">Por favor, faça login ou registre-se.</div>
        <div id="userCount"></div>

        <div id="auth-section" class="auth-section">
            <input type="email" id="email" placeholder="Email">
            <input type="password" id="password" placeholder="Senha">
            <div class="auth-buttons">
                <button id="loginBtn">Login</button>
                <button id="registerBtn">Registrar</button>
            </div>
            <button id="googleSignInBtn" style="background-color: #dd4b39; width: 100%; margin-top: 10px;">
                <i class="fab fa-google"></i> Login com Google
            </button>
        </div>

        <div id="comment-input-section" class="comment-input-section" style="display: none;">
            <div id="replyBox">
                <span id="replyMessageSpan"></span>
                <button id="cancelReplyBtn">x</button>
            </div>
            <textarea id="messageInput" placeholder="Seu comentário (suporta Markdown e @menções)"></textarea>
            <div id="mention-suggestions"></div> <button id="sendCommentBtn">Enviar</button>
            <button id="logoutBtn" style="background-color: #f44336;">Sair</button>
            <button id="deleteAccountBtn" style="background-color: #ff9800;">Apagar minha conta</button>
        </div>

        <div class="markdown-cheatsheet">
            <h3>Guia Rápido de Markdown:</h3>
            <ul>
                <li><strong>Negrito:</strong> `**texto**` ou `__texto__`</li>
                <li><em>Itálico:</em> `*texto*` ou `_texto_`</li>
                <li><span style="text-decoration: line-through;">Riscado:</span> `~~texto~~`</li>
                <li>`Código inline:` `` `codigo` ``</li>
                <li>`@menção`: `@NomeDoUsuario` (para usuários online)</li>
            </ul>
        </div>

        <div id="comments-section" class="comments-section">
            <h2>Comentários</h2>
            <div id="commentsDiv"></div>
        </div>
    </div>
      <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script> <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-storage-compat.js"></script> <script>
                // Suas configurações do Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyCmEEx1Z_QK7MblQnrezw5S7CXo1uzcCy4",
            authDomain: "comentarios-livro.firebaseapp.com",
            projectId: "comentarios-livro",
 o.appspot.com",
            messagingSenderId: "702096545512",
            appId: "1:702096545512:web:f7f3f00e0573d246c41b6d",
            measurementId: "G-7Q413000P5", // Este não estava explicitamente na imagem, mas geralmente é parte da config. Se você tiver um diferente, por favor ajuste.
            databaseURL: "https://comentarios-livro-default-rtdb.firebaseio.com" // Baseado no projectId, esta é a URL padrão do Realtime Database
        };

        // Substitua 'SEU_UID_DE_ADMIN_AQUI' pelo UID do seu usuário administrador
        const ADMIN_UID = "RTJkscPxu9MjMFL4RZSaILntfM13";
        

        // Inicializar Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const database = firebase.database();

        // Referências ao Realtime Database
        const commentsRef = database.ref("comentarios");
        const namesRef = database.ref("nomesUsados");
        const onlineRef = database.ref("logados");
        const bannedRef = database.ref("banidos");

        // Referências a elementos HTML
        const emailInput = document.getElementById("email");
        const passwordInput = document.getElementById("password");
        const loginBtn = document.getElementById("loginBtn");
        const registerBtn = document.getElementById("registerBtn");
        const googleSignInBtn = document.getElementById("googleSignInBtn");
        const logoutBtn = document.getElementById("logoutBtn");
        const deleteAccountBtn = document.getElementById("deleteAccountBtn");
        const messageInput = document.getElementById("messageInput");
        const sendCommentBtn = document.getElementById("sendCommentBtn");
        const commentsDiv = document.getElementById("commentsDiv");
        const statusDiv = document.getElementById("status");
        const authSection = document.getElementById("auth-section");
        const commentInputSection = document.getElementById("comment-input-section");
        const userCount = document.getElementById("userCount");

        const replyBox = document.getElementById("replyBox");
        const replyMessageSpan = document.getElementById("replyMessageSpan");
        const cancelReplyBtn = document.getElementById("cancelReplyBtn");
        let replyToCommentId = null;
        let replyToAuthorName = null;

        const mentionSuggestionsDiv = document.getElementById("mention-suggestions");
        let allOnlineUserNamesForMentions = []; // Para armazenar nomes de usuários online para sugestões

        // Elementos do prompt customizado
        const customPromptOverlay = document.getElementById('custom-prompt-overlay');
        const customPromptMessage = document.getElementById('custom-prompt-message');
        const customPromptInput = document.getElementById('custom-prompt-input');
        const customPromptTextarea = document.getElementById('custom-prompt-textarea');
        const customPromptConfirmBtn = document.getElementById('custom-prompt-confirm');
        const customPromptCancelBtn = document.getElementById('custom-prompt-cancel');

        // Elementos do prompt de nome de usuário
        const usernamePromptOverlay = document.getElementById('username-prompt-overlay');
        const usernameInput = document.getElementById('usernameInput');
        const saveUsernameBtn = document.getElementById('saveUsernameBtn');

        // Função para mostrar alertas customizados
        function showAlert(message, isError = false) {
            const alertBox = document.getElementById("alert-box");
            alertBox.textContent = message;
            alertBox.className = "alert-box"; // Reset classes
            if (isError) {
                alertBox.classList.add("error");
            }
            alertBox.style.opacity = "1";
            setTimeout(() => {
                alertBox.style.opacity = "0";
            }, 3000);
        }

        // Função para mostrar o prompt customizado
        function showCustomPrompt(message, inputType = "text", defaultValue = "") {
            return new Promise((resolve) => {
                customPromptMessage.textContent = message;
                customPromptInput.style.display = "none";
                customPromptTextarea.style.display = "none";

                let inputElement;
                if (inputType === "textarea") {
                    customPromptTextarea.style.display = "block";
                    customPromptTextarea.value = defaultValue;
                    inputElement = customPromptTextarea;
                } else {
                    customPromptInput.style.display = "block";
                    customPromptInput.value = defaultValue;
                    inputElement = customPromptInput;
                }

                customPromptOverlay.style.display = "flex";
                inputElement.focus();

                const handleConfirm = () => {
                    customPromptOverlay.style.display = "none";
                    resolve(inputElement.value);
                    removeListeners();
                };

                const handleCancel = () => {
                    customPromptOverlay.style.display = "none";
                    resolve(null);
                    removeListeners();
                };

                const handleKeyDown = (e) => {
                    if (e.key === 'Enter' && inputType === 'text') { // Permite Enter para 'text' input
                        handleConfirm();
                    } else if (e.key === 'Escape') { // Permite Esc para qualquer tipo de input
                        handleCancel();
                    }
                };

                customPromptConfirmBtn.addEventListener("click", handleConfirm);
                customPromptCancelBtn.addEventListener("click", handleCancel);
                inputElement.addEventListener("keydown", handleKeyDown);

                const removeListeners = () => {
                    customPromptConfirmBtn.removeEventListener("click", handleConfirm);
                    customPromptCancelBtn.removeEventListener("click", handleCancel);
                    inputElement.removeEventListener("keydown", handleKeyDown);
                };
            });
        }

        // Função para mostrar o prompt de nome de usuário
        async function showUsernamePrompt() {
            usernamePromptOverlay.style.display = 'flex';
            usernameInput.focus();
            return new Promise(resolve => {
                saveUsernameBtn.onclick = () => {
                    const username = usernameInput.value.trim();
                    if (username) {
                        usernamePromptOverlay.style.display = 'none';
                        resolve(username);
                    } else {
                        showAlert("Por favor, digite um nome de usuário.", true);
                    }
                };
            });
        }

        // Função para parsing de Markdown
        function parseMarkdown(text) {
            let html = text;
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); // Negrito **texto**
            html = html.replace(/__(.*?)__/g, '<strong>$1</strong>'); // Negrito __texto__
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');     // Itálico *texto*
            html = html.replace(/_(.*?)_/g, '<em>$1</em>');     // Itálico _texto_
            html = html.replace(/~~(.*?)~~/g, '<s>$1</s>');        // Riscado ~~texto~~
            html = html.replace(/`(.*?)`/g, '<code>$1</code>');  // Código inline `codigo`
            html = html.replace(/\n/g, '<br>'); // Quebra de linha
            return html;
        }

        // Iniciar resposta
        function startReply(commentId, authorName) {
            replyToCommentId = commentId;
            replyToAuthorName = authorName;
            replyMessageSpan.textContent = `Respondendo a ${authorName}`;
            replyBox.style.display = 'flex';
            messageInput.focus();
        }

        // Cancelar resposta
        function cancelReply() {
            replyToCommentId = null;
            replyToAuthorName = null;
            replyBox.style.display = 'none';
            replyMessageSpan.textContent = '';
        }

        // Event listener para o botão de cancelar resposta
        cancelReplyBtn.addEventListener('click', cancelReply);

        // FUNÇÕES PARA AUTOCOMPLETAR MENÇÕES
        async function updateMentionSuggestions() {
            const text = messageInput.value;
            const cursorPos = messageInput.selectionStart;
            const wordStart = text.lastIndexOf('@', cursorPos - 1);

            mentionSuggestionsDiv.innerHTML = '';
            mentionSuggestionsDiv.style.display = 'none';

            if (wordStart !== -1 && (wordStart === 0 || /\s/.test(text[wordStart - 1]))) {
                const mentionQuery = text.substring(wordStart + 1, cursorPos).toLowerCase();

                // Busca todos os usuários online e seus nomes (atualizado para ser mais eficiente)
                const onlineUsersSnapshot = await onlineRef.once("value");
                const onlineUserUids = [];
                onlineUsersSnapshot.forEach(child => onlineUserUids.push(child.key));

                const allUserNamesPromises = onlineUserUids.map(uid => namesRef.child(uid).once("value").then(snap => ({uid, name: snap.val()})));
                allOnlineUserNamesForMentions = (await Promise.all(allUserNamesPromises)).filter(u => u.name);

                const currentSuggestions = allOnlineUserNamesForMentions.filter(user => user.name.toLowerCase().startsWith(mentionQuery));

                if (currentSuggestions.length > 0) {
                    mentionSuggestionsDiv.style.display = 'block';
                    currentSuggestions.forEach(user => {
                        const item = document.createElement('div');
                        item.className = 'mention-suggestion-item';
                        item.textContent = user.name;
                        item.onclick = () => {
                            const before = text.substring(0, wordStart + 1);
                            const after = text.substring(cursorPos);
                            messageInput.value = before + user.name + ' ' + after;
                            mentionSuggestionsDiv.style.display = 'none';
                            messageInput.focus();
                        };
                        mentionSuggestionsDiv.appendChild(item);
                    });
                }
            }
        }

        messageInput.addEventListener('input', updateMentionSuggestions);
        messageInput.addEventListener('keydown', (e) => {
            if (mentionSuggestionsDiv.style.display === 'block' && (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'Enter')) {
                e.preventDefault(); // Evita o comportamento padrão do Enter/setas na textarea
                const items = Array.from(mentionSuggestionsDiv.children);
                if (items.length === 0) return;

                let currentIndex = items.findIndex(item => item.classList.contains('selected'));
                if (currentIndex === -1) currentIndex = -1; // No item selected initially

                if (e.key === 'ArrowDown') {
                    currentIndex = (currentIndex + 1) % items.length;
                } else if (e.key === 'ArrowUp') {
                    currentIndex = (currentIndex - 1 + items.length) % items.length;
                } else if (e.key === 'Enter') {
                    if (currentIndex !== -1) {
                        items[currentIndex].click(); // Simula o clique no item selecionado
                        return;
                    }
                }

                items.forEach((item, index) => {
                    if (index === currentIndex) {
                        item.classList.add('selected');
                        item.scrollIntoView({ block: 'nearest' });
                    } else {
                        item.classList.remove('selected');
                    }
                });
            } else {
                // Se o Enter for pressionado e não houver sugestões visíveis, o prompt será exibido normalmente
            }
        });
        messageInput.addEventListener('blur', () => {
            // Pequeno atraso para permitir que o clique na sugestão seja registrado
            setTimeout(() => {
                mentionSuggestionsDiv.style.display = 'none';
            }, 100);
        });

        // Autenticação
        loginBtn.addEventListener("click", async () => {
            try {
                await auth.signInWithEmailAndPassword(emailInput.value, passwordInput.value);
                showAlert("Login bem-sucedido!");
            } catch (error) {
                showAlert(`Erro de login: ${error.message}`, true);
                console.error("Erro de login:", error);
            }
        });

        registerBtn.addEventListener("click", async () => {
            try {
                const userCredential = await auth.createUserWithEmailAndPassword(emailInput.value, passwordInput.value);
                const user = userCredential.user;
                showAlert("Registro bem-sucedido!");

                // Se for um novo usuário, peça um nome de usuário
                const username = await showUsernamePrompt();
                if (username) {
                    await namesRef.child(user.uid).set(username);
                    showAlert("Nome de usuário salvo com sucesso!");
                } else {
                    showAlert("Nome de usuário não definido. Você pode configurá-lo mais tarde.", true);
                }
            } catch (error) {
                showAlert(`Erro de registro: ${error.message}`, true);
                console.error("Erro de registro:", error);
            }
        });

        googleSignInBtn.addEventListener("click", async () => {
            const provider = new firebase.auth.GoogleAuthProvider();
            try {
                const userCredential = await auth.signInWithPopup(provider);
                const user = userCredential.user;
                showAlert("Login com Google bem-sucedido!");

                // Verifica se o usuário já tem um nome
                const nameSnap = await namesRef.child(user.uid).once("value");
                if (!nameSnap.exists() || !nameSnap.val()) {
                    // Se não tiver nome, use o display name do Google ou peça um
                    const defaultName = user.displayName || user.email.split('@')[0];
                    const username = await showCustomPrompt("Escolha um nome de usuário:", "text", defaultName);
                    if (username) {
                        await namesRef.child(user.uid).set(username);
                        showAlert("Nome de usuário salvo com sucesso!");
                    } else {
                        showAlert("Nome de usuário não definido. Você pode configurá-lo mais tarde.", true);
                    }
                }
            } catch (error) {
                showAlert(`Erro ao fazer login com Google: ${error.message}`, true);
                console.error("Erro Google Sign-In:", error);
            }
        });

        logoutBtn.addEventListener("click", async () => {
            try {
                if (auth.currentUser) {
                    await onlineRef.child(auth.currentUser.uid).remove(); // Remove do online
                }
                await auth.signOut();
                showAlert("Logout bem-sucedido!");
            } catch (error) {
                showAlert(`Erro ao fazer logout: ${error.message}`, true);
                console.error("Erro de logout:", error);
            }
        });

        deleteAccountBtn.addEventListener("click", async () => {
            const user = auth.currentUser;
            if (!user) {
                showAlert("Nenhum usuário logado para apagar.", true);
                return;
            }

            const confirm = await showCustomPrompt("Tem certeza que deseja apagar sua conta? Isso é irreversível!", "text", "sim");
            if (confirm === "sim") {
                try {
                    // Apagar comentários do usuário
                    await commentsRef.orderByChild("uid").equalTo(user.uid).once("value", snapshot => {
                        snapshot.forEach(child => child.ref.remove());
                    });
                    // Apagar nome de usuário
                    await namesRef.child(user.uid).remove();
                    // Apagar status online
                    await onlineRef.child(user.uid).remove();

                    // Reautenticar antes de apagar a conta
                    // (Necessário para operações sensíveis, dependendo do provedor)
                    // Para email/senha:
                    if (user.providerData[0].providerId === 'password') {
                        const credential = firebase.auth.EmailAuthProvider.credential(user.email, passwordInput.value);
                        await user.reauthenticateWithCredential(credential);
                    }
                    // Para Google:
                    if (user.providerData[0].providerId === 'google.com') {
                        const provider = new firebase.auth.GoogleAuthProvider();
                        await user.reauthenticateWithPopup(provider);
                    }

                    await user.delete();
                    showAlert("Conta apagada com sucesso.");
                } catch (error) {
                    showAlert(`Erro ao apagar conta: ${error.message}. Por favor, faça login novamente e tente de novo.`, true);
                    console.error("Erro ao apagar conta:", error);
                }
            } else {
                showAlert("Operação cancelada.", true);
            }
        });

        sendCommentBtn.addEventListener("click", async () => {
            const user = auth.currentUser;
            if (!user) {
                showAlert("Por favor, faça login para comentar.", true);
                return;
            }

            const message = messageInput.value.trim();
            if (!message) {
                showAlert("A mensagem não pode estar vazia.", true);
                return;
            }

            try {
                const nameSnap = await namesRef.child(user.uid).once("value");
                const name = nameSnap.val();

                if (!name) {
                    showAlert("Nome de usuário não encontrado. Por favor, defina um nome.", true);
                    const newUsername = await showUsernamePrompt();
                    if (newUsername) {
                        await namesRef.child(user.uid).set(newUsername);
                        showAlert("Nome de usuário salvo. Tente enviar o comentário novamente.");
                    }
                    return;
                }

                const newComment = {
                    uid: user.uid,
                    name: name,
                    message: message,
                    timestamp: firebase.database.ServerValue.TIMESTAMP,
                    replyToId: replyToCommentId,
                    replyToAuthor: replyToAuthorName
                };

                await commentsRef.push(newComment);
                messageInput.value = "";
                cancelReply(); // Limpa a caixa de resposta após enviar
                showAlert("Comentário enviado!");
            } catch (error) {
                showAlert(`Erro ao enviar comentário: ${error.message}`, true);
                console.error("Erro ao enviar comentário:", error);
            }
        });

        // Monitorar estado de autenticação
        auth.onAuthStateChanged(async (user) => {
            if (user) {
                statusDiv.textContent = `✅ Logado como: ${user.email}`;
                authSection.style.display = "none";
                commentInputSection.style.display = "block";

                // Verificar e definir nome de usuário
                const nameSnap = await namesRef.child(user.uid).once("value");
                if (!nameSnap.exists() || !nameSnap.val()) {
                    const username = await showUsernamePrompt();
                    if (username) {
                        await namesRef.child(user.uid).set(username);
                        showAlert("Nome de usuário salvo com sucesso!");
                    }
                } else {
                    statusDiv.textContent = `✅ Logado como: ${nameSnap.val()}`;
                }

                // Definir status online
                onlineRef.child(user.uid).set(true);
                // Remover status online ao desconectar
                onlineRef.child(user.uid).onDisconnect().remove();

                // Checar se o usuário está banido
                const bannedSnap = await bannedRef.child(user.uid).once("value");
                if (bannedSnap.exists() && bannedSnap.val() === true) {
                    showAlert("Você foi banido e não pode comentar.", true);
                    sendCommentBtn.disabled = true;
                    messageInput.disabled = true;
                } else {
                    sendCommentBtn.disabled = false;
                    messageInput.disabled = false;
                }

            } else {
                statusDiv.textContent = "Por favor, faça login ou registre-se.";
                authSection.style.display = "block";
                commentInputSection.style.display = "none";
                sendCommentBtn.disabled = false; // Reabilitar se deslogado
                messageInput.disabled = false;
            }
        });

        // Carregar e exibir comentários
        commentsRef.on("value", async snapshot => {
            commentsDiv.innerHTML = ""; // Limpa os comentários existentes para evitar duplicação!
            const user = auth.currentUser;
            const isAdmin = user && user.uid === ADMIN_UID;

            const commentsArray = [];
            snapshot.forEach(child => {
                commentsArray.push({ key: child.key, ...child.val() });
            });

            commentsArray.sort((a, b) => a.timestamp - b.timestamp);

            // Fetch all online users and their names ONCE per commentsRef update
            const onlineUsersSnapshot = await onlineRef.once("value");
            const onlineUserUids = [];
            onlineUsersSnapshot.forEach(child => onlineUserUids.push(child.key));
            const allUserNamesPromises = onlineUserUids.map(uid => namesRef.child(uid).once("value").then(snap => snap.val()));
            const allOnlineUserNames = (await Promise.all(allUserNamesPromises)).filter(name => name); // Get all existing names


            // Usando Promise.all para buscar comentários originais em paralelo para performance
            const commentsWithReplyData = await Promise.all(commentsArray.map(async (c) => {
                let replyToHtml = '';
                if (c.replyToId && c.replyToAuthor) {
                    const originalCommentSnap = await commentsRef.child(c.replyToId).once("value");
                    if (originalCommentSnap.exists()) {
                        const originalComment = originalCommentSnap.val();
                        // Pega os primeiros 80 caracteres da mensagem original para o snippet
                        const originalMessageSnippet = originalComment.message.substring(0, 80) + (originalComment.message.length > 80 ? '...' : '');
                        replyToHtml = `
                            <div class="comment-reply-block">
                                <span class="reply-block-author">${originalComment.name}</span>
                                <span class="reply-block-message">${originalMessageSnippet}</span>
                            </div>
                        `;
                    } else {
                        replyToHtml = `
                            <div class="comment-reply-block comment-reply-deleted">
                                <span class="reply-block-message">[Mensagem original apagada]</span>
                            </div>
                        `;
                    }
                }
                return { ...c, replyToHtml: replyToHtml };
            }));


            for (const c of commentsWithReplyData) { // Percorre o novo array com replyHtml
                const div = document.createElement("div");
                div.className = "comment";

                if (user && user.uid === c.uid) {
                    div.classList.add("own");
                }
                if (c.uid === ADMIN_UID) {
                    div.classList.add("admin");
                }

                const date = new Date(c.timestamp);
                const dataFormatada = `${String(date.getDate()).padStart(2, '0')}/${String(date.getMonth() + 1).padStart(2, '0')}/${date.getFullYear()} - ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;

                // Aplica o parsing de markdown à mensagem
                let messageContent = parseMarkdown(c.message);

                // Agora, lida com as menções dentro da mensagem formatada.
                // Itera sobre os nomes para substituir, começando com nomes mais longos para evitar correspondências parciais
                allOnlineUserNames.sort((a, b) => b.length - a.length).forEach(name => {
                    // Regex para encontrar @nomeUsuario. Garante que é um limite de palavra para o nome de usuário.
                    const regex = new RegExp(`@${name}\\b`, 'g'); // \b para limite de palavra
                    messageContent = messageContent.replace(regex, `<span class="mention">@${name}</span>`);
                });

                // Usa o replyToHtml pré-buscado e o messageContent recém-formatado
                div.innerHTML = `
                    <div class="comment-header">
                        <span class="comment-author">${c.name}</span>
                        <span class="comment-timestamp">(${dataFormatada})</span>
                    </div>
                    ${c.replyToHtml}
                    <div class="comment-message">${messageContent}</div> `;

                const actionsDiv = document.createElement("div");
                actionsDiv.className = "comment-actions";

                const replyBtn = document.createElement("button");
                replyBtn.textContent = "Responder";
                replyBtn.onclick = () => {
                    startReply(c.key, c.name); // Usa c.key (ID do comentário) e c.name para resposta
                };
                actionsDiv.append(replyBtn);


                if (user && user.uid === c.uid) {
                    const editBtn = document.createElement("button");
                    editBtn.textContent = "Editar";
                    editBtn.onclick = async () => {
                        const novoTexto = await showCustomPrompt("Edite sua mensagem:", "textarea", c.message);
                        if (novoTexto !== null) {
                            if (novoTexto.trim() !== "") {
                                commentsRef.child(c.key).update({ message: novoTexto });
                            } else {
                                showAlert("Mensagem não pode ser vazia.", true);
                            }
                        }
                    };

                    const deleteOwnBtn = document.createElement("button");
                    deleteOwnBtn.textContent = "Apagar Mensagem";
                    deleteOwnBtn.onclick = async () => {
                        const confirmDelete = await showCustomPrompt("Tem certeza que deseja apagar esta mensagem?", "text", "sim");
                        if (confirmDelete === "sim") {
                            commentsRef.child(c.key).remove();
                            showAlert("Mensagem apagada.");
                        } else {
                            showAlert("Operação cancelada.", true);
                        }
                    };
                    actionsDiv.append(editBtn, deleteOwnBtn);
                }

                if (isAdmin && c.uid !== ADMIN_UID) {
                    const adminBox = document.createElement("div");
                    adminBox.className = "admin-buttons";

                    const del = document.createElement("button");
                    del.textContent = "🗑️ Apagar";
                    del.onclick = async () => {
                        const confirmDel = await showCustomPrompt("Tem certeza que deseja apagar esta mensagem?", "text", "sim");
                        if (confirmDel === "sim") {
                            commentsRef.child(c.key).remove();
                            showAlert("Mensagem apagada pelo admin.");
                        } else {
                            showAlert("Operação cancelada.", true);
                        }
                    };

                    const ban = document.createElement("button");
                    ban.textContent = "🚫 Banir Usuário";
                    ban.onclick = async () => {
                        const confirmBan = await showCustomPrompt(`Tem certeza que deseja banir ${c.name}? Isso também apagará os comentários dele.`, "text", "sim");
                        if (confirmBan === "sim") {
                            bannedRef.child(c.uid).set(true);
                            await showCustomAlert(`${c.name} foi banido.`);
                            await commentsRef.orderByChild("uid").equalTo(c.uid).once("value", snapshot => {
                                snapshot.forEach(child => child.ref.remove());
                            });
                            onlineRef.child(c.uid).remove();
                        } else {
                            showAlert("Operação cancelada.", true);
                        }
                    };
                    adminBox.append(del, ban);
                    actionsDiv.appendChild(adminBox);
                }

                if (actionsDiv.children.length > 0) {
                    div.appendChild(actionsDiv);
                }

                commentsDiv.appendChild(div);
            }
        });

        onlineRef.on("value", snap => {
            userCount.textContent = `👥 Usuários online: ${snap.numChildren()}`;
        });
    </script>
</body>
</html>
